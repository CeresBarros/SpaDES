% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel.R
\docType{methods}
\name{experiment}
\alias{experiment}
\alias{experiment,simList-method}
\title{Run an experiment using spades}
\usage{
experiment(sim, replicates = 1, params = list(), modules = list(),
  objects = list(), inputs = list(), dirPrefix = "simNum",
  substrLength = 3, experimentFile = "experiment.csv", ...)

\S4method{experiment}{simList}(sim, replicates = 1, params = list(),
  modules = list(), objects = list(), inputs = list(),
  dirPrefix = "simNum", substrLength = 3,
  experimentFile = "experiment.csv", ...)
}
\arguments{
\item{sim}{A \code{simList} simulation object, generally produced by \code{simInit}.}

\item{replicates}{The number of replicates to run of the same \code{simList}}

\item{params}{A named list of simulation parameters and their values.}

\item{modules}{A named list of character strings specfying the names
of modules to be loaded for the simulation. Note: the module name
should correspond to the R source file from which the module is loaded.
Example: a module named "caribou" will be sourced form the file
\file{caribou.R}, located at the specified \code{modulePath(simList)} (see below).}

\item{objects}{An optional list of data objects to be used in the simulation.}

\item{inputs}{A \code{data.frame}. Can specify from 1 to 6
columns with following column names: \code{objectName} (character, required),
\code{file} (character), \code{fun} (character), \code{package} (character),
\code{interval} (numeric), \code{loadTime} (numeric).
See \code{\link{inputs}} and vignette("ii-modules") section about inputs.}

\item{dirPrefix}{String vector. This will be concatenated as a prefix on the directory names.
See Details.}

\item{substrLength}{Numeric. While making \code{outputPath}, this is the number of characters
kept from each factor level. See Details.}

\item{experimentFile}{String. Filename of the experiment data.frame to be saved in
\code{outputPath(sim)}. Saved as a csv. See Details.}

\item{...}{Passed to \code{spades}. This would only be useful for \code{debug=TRUE}.}
}
\value{
Invisibly returns a list of the resulting \code{simList} objects from the fully
factorial experiment. This list has an attribute, which is the experiment data.frame.
Since this may be large, the user is not obliged to return this object (as it is returned invisibly).
Clearly, there may be objects saved during simulations. This would be determined as per a
normal \code{\link{spades}} call, using \code{outputs}.
}
\description{
This is essentially a wrapper around the \code{spades} call that allows for multiple
calls to spades. Generally, there are 2 reasons to do this: replication and varying inputs
to accomplish some sort of simulation experiment. This function deals with both of these
cases. In the case of varying inputs, this function will create a fully factorial experiment
among all levels of the variables passed into the function, if they are parameters. If varying
modules are passed into the function, then it is likewise fully factorial. However, if it is both
varying parameters and varying modules, then it may not make sense to be fully factorial as some
parameters that are varying may not be defined in all module sets. The function will fully
factorial where it makes sense to do this, and a complete set otherwise. The function
requires a \code{simList} object, plus optional inputs and/or params and/or modules and/or
replications. Future updates will allow varying objects.
}
\details{
This function requires a complete simList. All values passed into this function will
override the \code{simList} values.

There are a few behaviours that are assumed, notably with output directories. If there
are only replications, then a set of subdirectories will be created, one for each replicate.
If there are varying parameters and or modules, \code{outputPath} is updated to include
a subdirectory for each level of the experiment. These are not nested, i.e., even if there
are nexted factors, all subdirectories will be at the same level.
The subdirectory names will include the module(s), parameter names, the parameter values,
and input index number (i.e., which row of the inputs data.frame).
The default rule for naming is a concatenation of:

1. The experiment level (arbitrarily starting at 1).

2. The module, parameter name and parameter value, for each parameter that is varying.

3. The module set.

4. The input index number

5. Individual identifiers are separated by a dash.

6. Module - Parameter - Parameter value triplets are separated by underscore.

This subdirectory name could be long
if there are many dimensions to the experiment. The parameter \code{substrLength} determines
the level of truncation of the parameter, module and input names for these subdirectories. For example,
The  resulting directory name for a parameter value of 0.225 for the \code{spreadprob} parameter in the
\code{fireSpread} module and the \code{N} parameter in the \code{caribouMovement} module would be:
\code{1_fir_spr_0.225-car_N_10} if \code{substrLength} is 3, the default.

Replication is treated slightly differently. \code{outputPath} is always 1 level below the
experiment level for a replicate.
If the call to \code{experiment} is not a factoria experiment (i.e., it is just replication), then the
default is to put the replicate subdirectories at the top level of \code{outputPath}. To force
this one level down, \code{dirPrefix} can be used or a manual change to \code{outputPath} before
the call to experiment.

\code{dirPrefix} can be used to give custom names to directories for outputs. There is a special
value, \code{"simNum"}, that is used as default, which is an arbitrary number associated with the
experiment. This corresponds to the row number in the \code{attr(sims, "experiment")}.
This \code{"simNum"} can be used with other strings, such as \code{dirPrefix=c("expt","simNum")}.

The experiment structure is kept in two places: the return object has an attribute, and a file
named "experiment.rds" (see argument \code{experimentFile}) located in \code{outputPath(sim)}.

\code{substrLength}, if \code{0}, this will eliminate the subfolder naming convention and use
only \code{dirPrefix}.
}
\examples{
\dontrun{

 library(raster)
 beginCluster(8)
 startFiles <- dir(file.path(tempdir()), full.names=TRUE, recursive=TRUE)

# Example of changing parameter values
 mySimFull <- simInit(
   times = list(start = 0.0, end = 2.0, timeunit = "year"),
   params = list(
     .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
     # Turn off interactive plotting
     fireSpread = list(.plotInitialTime=NA),
     caribouMovement = list(.plotInitialTime=NA),
     randomLandscapes = list(.plotInitialTime=NA)
   ),
   modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
   paths = list(modulePath = system.file("sampleModules", package = "SpaDES"),
                outputPath = tempdir()),
   # Save final state of landscape and caribou
   outputs = data.frame(objectName=c("landscape", "caribou"), stringsAsFactors=FALSE)
 )


 # Create an experiment - here, 2 x 2 x 2 (2 levels of 2 params in fireSpread,
 #    and 2 levels of 1 param in caribouMovement)
 experimentParams <- list(fireSpread = list(spreadprob = c(0.2, 0.23),
                                             nFires = c(20, 10)),
                       caribouMovement = list(N = c(100, 1000)))

 sims <- experiment(mySimFull, params=experimentParams)
 exptDesign <- read.csv(file.path(tempdir(), "experiment.csv"))

 # see experiment:
 attr(sims, "experiment")

 # Read in outputs from sims object
 FireMaps = do.call(stack, lapply(1:NROW(attr(sims,"experiment")),
                    function(x) sims[[x]]$landscape$Fires))
 Plot(FireMaps, new=TRUE)

 # Or reload objects from files, useful if sim objects too large to store in RAM
 caribouMaps <- lapply(sims, function(sim) {
   caribou <- readRDS(outputs(sim)$file[outputs(sim)$objectName=="caribou"])
   }
 )
 names(caribouMaps) <- paste0("caribou",1:8)
 # Plot does not plot whole lists (yet)
 Plot(caribouMaps[[1]], caribouMaps[[2]], caribouMaps[[3]], caribouMaps[[4]],
      caribouMaps[[5]], caribouMaps[[6]], caribouMaps[[7]], caribouMaps[[8]],
      size=0.1)

# Remove all temp files
unlink(dir(tempdir(), full.names=TRUE)[!(dir(tempdir(),
              full.names=TRUE) \%in\% startFiles)], recursive=TRUE)
#######
# Example of changing modules, i.e., caribou with and without fires
 # Create an experiment - here, 2 x 2 x 2 (2 levels of 2 params in fireSpread,
 #    and 2 levels of 1 param in caribouMovement)
 experimentModules <- list(
     c("randomLandscapes", "fireSpread", "caribouMovement"),
     c("randomLandscapes", "caribouMovement")
     )

 # Note, this isn't fully factorial because all parameters are not defined inside smaller module list
 sims <- experiment(mySimFull, modules=experimentModules, params=experimentParams)

 # manipulate directory names
 sims <- experiment(mySimFull, params=experimentParams, dirPrefix=c("expt", "simNum"))

 # doing replicate runs - THESE MAY TAKE SOME TIME (minutes if not using a cluster)
 sims <- experiment(mySimFull, replicates = 2)
 # putting them in a subdirectory
 sims <- experiment(mySimFull, replicates = 2, dirPrefix = c("expt"))

 # Both replication and experiment, both params and modules
 # use a sub directory
 outputPath(mySimFull) <- file.path(tempdir(), "myExpt3")
 sims <- experiment(mySimFull, replicates = 2, params=experimentParams,
                    dirPrefix=c("expt", "simNum"))

 # Use replication to build a probability surface.
 # For this to be meaningful, we need to provide a fixed landscape,
 #   not a randomLandscape for each experiment level. So requires 2 steps.
 # Step 1 - run randomLandscapes once to get a landscape map
 mySimRL <- simInit(
   times = list(start = 0.0, end = 0.1, timeunit = "year"),
   params = list(
     .globals = list(stackName = "landscape"),
     # Turn off interactive plotting
     randomLandscapes = list(.plotInitialTime=NA)
   ),
   modules = list("randomLandscapes"),
   paths = list(modulePath = system.file("sampleModules", package = "SpaDES"),
                outputPath = file.path(tempdir(), "landscapeMaps1")),
   outputs = data.frame(objectName="landscape", saveTime = 0, stringsAsFactors=FALSE)
 )
 # Run it twice to get two copies of the randomly generated landscape
 mySimRLOut <- experiment(mySimRL, replicate=2)
 #extract the landscape, which will be passed into next as an object
 landscape <- mySimRLOut[[1]]$landscape

 mySimCarFir <- simInit(
   times = list(start = 0.0, end = 1, timeunit = "year"),
   params = list(
     .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
     # Turn off interactive plotting
     fireSpread = list(.plotInitialTime=NA),
     caribouMovement = list(.plotInitialTime=NA)
   ),
   modules = list("fireSpread", "caribouMovement"), # No randomLandscapes modules
   paths = list(modulePath = system.file("sampleModules", package = "SpaDES"),
                outputPath = tempdir()),
   objects = c("landscape"), # Pass in the object here
   # Save final state of landscape and caribou
   outputs = data.frame(objectName=c("landscape", "caribou"), stringsAsFactors=FALSE)
 )

 outputPath(mySimCarFir) <- file.path(tempdir(), "myExpt6")
 sims <- experiment(mySimCarFir, replicates = 8) # Run experiment
 attr(sims, "experiment") # shows the experiment, which in this case is just replicates
 # list all files that were saved called 'landscape'
 files1 <- dir(outputPath(mySimCarFir), recursive=TRUE, pattern="landscape", full.names=TRUE)
 # Read them in - alternatively, this could use the sims object directly also, e.g., sims[[1]]$landscape$Fires
 landscapes <- lapply(files1, readRDS)
 fires1 <- do.call(stack, lapply(landscapes, function(x) x$Fires)) # Extract just Fire layer
 fires1[fires1>0] <- 1 # convert to 1s and 0s
 fireProb <- sum(fires1)/nlayers(fires1) # sum them and convert to probability
 Plot(fireProb, new=TRUE)

 ### Changing inputs
 mySimCarFir2 <- simInit(
   times = list(start = 0.0, end = 2.0, timeunit = "year"),
   params = list(
     .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
     # Turn off interactive plotting
     fireSpread = list(.plotInitialTime=NA),
     caribouMovement = list(.plotInitialTime=NA)
   ),
   modules = list("fireSpread", "caribouMovement"),
   paths = list(modulePath = system.file("sampleModules", package = "SpaDES"),
                outputPath = tempdir()),
   # Save final state of landscape and caribou
   outputs = data.frame(objectName=c("landscape", "caribou"), stringsAsFactors=FALSE)
 )
 landscapeFiles <- dir(tempdir(), pattern="landscape_year0", recursive=TRUE, full.names=TRUE)
 experiment(mySimCarFir2, params=experimentParams, replicates = 2,
   inputs=lapply(landscapeFiles,function(filenames) {
     data.frame(file = filenames, loadTime=0, objectName= "landscape", stringsAsFactors = FALSE) })
  )
 exptDesign <- read.csv(file.path(tempdir(), "experiment.csv"))
 print(exptDesign)

 # Use simple outputPath file names
 experiment(mySimFull, modules=experimentModules, substrLength=0)
 exptDesign <- read.csv(file.path(tempdir(), "experiment.csv"))
 print(exptDesign)

 endCluster()

# Remove all temp files
unlink(dir(tempdir(), full.names=TRUE)[!(dir(tempdir(),
                    full.names=TRUE) \%in\% startFiles)], recursive=TRUE)
}

}
\author{
Eliot McIntire
}
\seealso{
\code{\link{simInit}}, \code{\link{SpaDES}}
}

