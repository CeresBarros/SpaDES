% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spread-dt.R
\docType{methods}
\name{spreadDT}
\alias{spreadDT}
\alias{spreadDT,RasterLayer-method}
\title{Simulate a contagious spread process on a landscape, with data.table internals}
\usage{
spreadDT(landscape, start = ncell(landscape)/2 - ncol(landscape)/2,
  spreadProb = 0.23, asRaster = TRUE, size, exactSize = FALSE,
  directions = 8L, iterations = 1000000L, returnDistances = FALSE,
  plot.it = FALSE, circle = FALSE, allowOverlap = FALSE,
  neighProbs = NA_real_, skipChecks = FALSE, ...)

\S4method{spreadDT}{RasterLayer}(landscape, start = ncell(landscape)/2 -
  ncol(landscape)/2, spreadProb = 0.23, asRaster = TRUE, size,
  exactSize = FALSE, directions = 8L, iterations = 1000000L,
  returnDistances = FALSE, plot.it = FALSE, circle = FALSE,
  allowOverlap = FALSE, neighProbs = NA_real_, skipChecks = FALSE, ...)
}
\arguments{
\item{landscape}{A \code{RasterLayer} object. This defines the possible locations
for spreading events to start and spreadDT into. Required.}

\item{start}{Either a vector of pixel numbers to initiate spreading, or a
data.table that is the output of a previous \code{spreadDT}.
If a vector, they should be cell indices (pixels) on the \code{landscape}.
If user has x and y coordinates, these can be converted with
\code{\link[raster]{cellFromXY}}.}

\item{spreadProb}{Numeric or rasterLayer. If numeric of length 1, then this is
the global probability of
spreading into each cell from a neighbor. If a raster then this must
be the cell-specific probability of a "receiving" potential cell.
Default is \code{0.23}.}

\item{asRaster}{Logical, length 1. If \code{TRUE}, the function will return a \code{Raster}
where raster non NA values indicate the cells that were "actived", and the
value is the initial starting pixel.}

\item{size}{Numeric. Maximum number of cells for a single or
all events to be spreadDT. Recycled to match \code{start} length,
if it is not as long as \code{start}.
See section on \code{Breaking out of spreadDT events}.}

\item{exactSize}{Logical. If TRUE, then the \code{size} will be treated as exact sizes,
i.e., the spreadDT events will continue until they are
\code{floor(size)}. This is overridden by \code{iterations}, but
if \code{iterations} is run, and individual events haven't reached
\code{size}, then the returned \code{data.table} will still have
at least one active cell per event that did not achieve \code{size},
so that the events can continue if passed into \code{spreadDT} with
\code{spreadState}.}

\item{directions}{The number adjacent cells in which to look;
default is 8 (Queen case). Can only be 4 or 8.}

\item{iterations}{Number of iterations to spreadDT.
Leaving this \code{NULL} allows the spreadDT to continue
until stops spreading itself (i.e., exhausts itself).}

\item{returnDistances}{Logical. Should the function inclue a column with the
individual cell distances from the locus where that event
started. Default is FALSE. See Details.}

\item{plot.it}{If TRUE, then plot the raster at every iteraction,
so one can watch the spreadDT event grow.}

\item{circle}{Logical. If TRUE, then outward spreadDT will be by equidistant rings,
rather than solely by adjacent cells (via \code{directions} arg.). Default
is FALSE. Using \code{circle = TRUE} can be dramatically slower for large
problems. Note, this will likely create unexpected results if \code{spreadProb} < 1.}

\item{allowOverlap}{Logical. If \code{TRUE}, then individual events can overlap with one
another, i.e., they do not interact. Currently, this is slower than
if \code{allowOverlap} is \code{FALSE}. Default is \code{FALSE}.}

\item{neighProbs}{An optional numeric vector, whose sum is 1. It indicates the
probabilities that an individual
spread iteration will spread to \code{1, 2, ..., length(neighProbs)}
neighbours, respectively.}

\item{skipChecks}{Logical. If TRUE, then several potentially time consuming checking (such as
\code{inRange}) will be skipped. This should only be used if there is no
concern about checking to ensure that inputs are legal, i.e., if this call
is using the previous output from this same call.}

\item{...}{Additional named vectors or named list of named vectors
required for \code{stopRule}. These
vectors should be as long as required e.g., length
\code{start} if there is one value per event.}
}
\value{
Either a \code{RasterLayer} (if \code{asRaster} is \code{TRUE}, the default).
If a \code{RasterLayer}, then it represents
every cell in which a successful spreadDT event occurred. For the case of, say, a fire
this would represent every cell that burned. If \code{allowOverlap} is \code{TRUE},
the return will always be a \code{data.table}.

If \code{asRaster} is false, then this function returns a \code{data.table} with columns:

\tabular{ll}{
  \code{id} \tab an arbitrary ID \code{1:length(start)} identifying
                     unique clusters of spreadDT events, i.e., all cells
                     that have been spreadDT into that have a
                     common initial cell.\cr
  \code{initialLocus} \tab the initial cell number of that particular
                           spreadDT event.\cr
  \code{indices} \tab The cell indices of cells that have
                       been touched by the spreadDT algorithm.\cr
  \code{active} \tab a logical indicating whether the cell is active (i.e.,
                       could still be a source for spreading) or not (no
                       spreading will occur from these cells).\cr
}

This will generally be more useful when \code{allowOverlap} is \code{TRUE}.
}
\description{
This can be used to simulate fires, seed dispersal, calculation of iterative,
concentric landscape values (symmetric or asymmetric) and many other things.
Essentially, it starts from a collection of cells (\code{start}) and spreads
to neighbours, according to the \code{directions} and \code{spreadProb} arguments.
}
\details{
There are 2 main underlying algorithms: \code{spreadProb} and \code{neighProb}.
Using \code{spreadProb}, every "active" pixel will assess all
neighbours (either 4 or 8, depending on  \code{directions}), and will "activate"
whichever neighbours successfully pass \code{runif(1,0,1)<spreadProb}. The algorithm
will iterate again and again, each time starting from the newly "activated" cells.

This function can be interrupted before all active cells are exhausted if
the \code{iterations} value is reached before there are no more active
cells to spreadDT into. The interrupted output (a data.table) can be passed subsequently
as an input to this same function (as \code{start}). This is intended
to be used for situations where external
events happen during a spreadDT event, or where one or more arguments to the spreadDT
function change before a spreadDT event is completed. For example, if it is
desired that the \code{spreadProb} change before a spreadDT event is completed because,
for example, a fire is spreading, and a new set of conditions arise due to
a change in weather.
}
\section{Breaking out of spreadDT events}{


There are 3 ways for the spreadDT to "stop" spreading. Here, each "event" is defined as
all cells that are spawned from each unique \code{start} location.
So, one spreadDT call can have
multiple spreading "events". The ways outlined below are all acting at all times,
i.e., they are not mutually exclusive. Therefore, it is the user's
responsibility to make sure the different rules are interacting with
each other correctly.

\tabular{ll}{
  \code{spreadProb} \tab Probabilistically, if spreadProb is low enough,
                         active spreading events will stop. In practice,
                         active spreading events will stop. In practice,
                         this number generally should be below 0.3 to actually
                         see an event stop\cr
  \code{size} \tab This is the number of cells that are "successfully" turned
                      on during a spreading event. This can be vectorized, one value
                      for each event   \cr
  \code{iterations} \tab This is a hard cap on the number of internal iterations to
                         complete before returning the current state of the system
                         as a data.table \cr
}
}

\examples{
library(raster)
library(RColorBrewer)

# Make random forest cover map
set.seed(123)
emptyRas <- raster(extent(0, 1e2, 0, 1e2), res = 1)
hab <- randomPolygons(emptyRas, numTypes = 40)
names(hab) <- "hab"
mask <- raster(emptyRas)
mask <- setValues(mask, 0)
mask[1:5000] <- 1
numCol <- ncol(emptyRas)
numCell <- ncell(emptyRas)
directions <- 8

# Can use transparent as a color
setColors(hab) <- paste(c("transparent", brewer.pal(8, "Greys")))

# note speedup is equivalent to making pyramids, so, some details are lost
if (interactive()) {
  clearPlot()
  Plot(hab, speedup = 3)
}

# initiate 10 fires
startCells <- as.integer(sample(1:ncell(emptyRas),100))
fires <- spread(hab, loci = startCells, 0.235, persistence = 0, numNeighs = 2,
                mask = NULL, maxSize = 1e8, directions=8, iterations=1e6, id = TRUE)

#set colors of raster, including a transparent layer for zeros
setColors(fires, 10) <- c("transparent", brewer.pal(8, "Reds")[5:8])
if (interactive()) {
  Plot(fires)
  Plot(fires, addTo = "hab")

  #alternatively, set colors using cols= in the Plot function
  clearPlot()
  Plot(hab)
  Plot(fires) # default color range makes zero transparent.
  # Instead, to give a color to the zero values, use \\code{zero.color=}
  Plot(fires, addTo = "hab",
       cols = colorRampPalette(c("orange","darkred"))(10), zero.color = "transparent")
  hab2 <- hab
  Plot(hab2)
  Plot(fires, addTo = "hab2", zero.color = "transparent",
     cols = colorRampPalette(c("orange","darkred"))(10))
  # or overplot the original (NOTE: legend stays at original values)
  Plot(fires, cols = topo.colors(10), new = TRUE, zero.color = "white")
}

####################
## Continue event by passing interrupted object into spreadState
####################

## Interrupt a spread event using iterations - need returnIndices = TRUE to use outputs
##   as new inputs in next iteration
fires <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)),
                returnIndices = TRUE, 0.235, 0, NULL, 1e8, 8, iterations = 3, id = TRUE)
fires[, list(size = length(initialLocus)), by = id]  # See sizes of fires

fires2 <- spread(hab, loci = NA_real_, returnIndices = TRUE, 0.235, 0, NULL,
                 1e8, 8, iterations = 2, id = TRUE, spreadState = fires)
# NOTE events are assigned arbitrary IDs, starting at 1

## Add new fires to the already burning fires
fires3 <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)),
                 returnIndices = TRUE, 0.235, 0, NULL, 1e8, 8, iterations = 1,
                 id = TRUE, spreadState = fires)
fires3[, list(size = length(initialLocus)), by = id]  # See sizes of fires
# NOTE old ids are maintained, new events get ids begining above previous
# maximum (e.g., new fires 11 to 20 here)

## Use data.table and loci...
fires <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)),
                returnIndices = TRUE, 0.235, 0, NULL, 1e8, 8, iterations = 2, id = TRUE)
fullRas <- raster(hab)
fullRas[] <- 1:ncell(hab)
burned <- fires[active == FALSE]
burnedMap <- rasterizeReduced(burned, fullRas, "id", "indices")
if (interactive()) {
  clearPlot()
  Plot(burnedMap, new = TRUE)
}

####################
## stopRule examples
####################

# examples with stopRule, which means that the eventual size is driven by the values on the raster
#  passed in to the landscape argument
set.seed(1234)
stopRule1 <- function(landscape) sum(landscape) > 50
stopRuleA <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)), 1, 0, NULL,
                    maxSize = 1e6, 8, 1e6, id = TRUE, circle = TRUE, stopRule = stopRule1)

set.seed(1234)
stopRule2 <- function(landscape) sum(landscape) > 100
# using stopRuleBehavior = "excludePixel"
stopRuleB <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)), 1, 0, NULL,
                    maxSize = 1e6, 8, 1e6, id = TRUE, circle = TRUE, stopRule = stopRule2,
                    stopRuleBehavior = "excludePixel")

# using stopRuleBehavior = "includeRing", means that end result is slightly larger patches, as a
#  complete "iteration" of the spread algorithm is used.
set.seed(1234)
stopRuleB_NotExact <- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)), 1, 0,
                NULL, maxSize = 1e6, 8, 1e6, id = TRUE, circle = TRUE, stopRule = stopRule2)
if (interactive()) {
  clearPlot()
  Plot(stopRuleA, stopRuleB, stopRuleB_NotExact)
}

# Test that the stopRules work
# stopRuleA was not exact, so each value will "overshoot" the stopRule, here it was hab>50
foo <- cbind(vals = hab[stopRuleA], id = stopRuleA[stopRuleA > 0]);
tapply(foo[, "vals"], foo[, "id"], sum) # Correct ... all are above 50

# stopRuleB was exact, so each value will be as close as possible while rule still is TRUE
#  Because we have discrete cells, these numbers will always slightly under the rule
foo <- cbind(vals = hab[stopRuleB], id = stopRuleB[stopRuleB > 0]);
tapply(foo[, "vals"], foo[, "id"], sum) # Correct ... all are above 50

# stopRuleB_notExact will overshoot
foo <- cbind(vals = hab[stopRuleB_NotExact], id = stopRuleB_NotExact[stopRuleB_NotExact > 0]);
tapply(foo[, "vals"], foo[, "id"], sum) # Correct ... all are above 50

# Cellular automata shapes
# Diamonds - can make them with: a boolean raster, directions = 4,
#    stopRule in place, spreadProb = 1
diamonds <- spread(hab > 0, spreadProb = 1, directions = 4, id = TRUE, stopRule = stopRule2)
if (interactive()) {
  clearPlot()
  Plot(diamonds)
}

# Squares - can make them with: a boolean raster, directions = 8,
#    stopRule in place, spreadProb = 1
squares <- spread(hab > 0, spreadProb = 1, directions = 8, id = TRUE, stopRule = stopRule2)
if (interactive()) Plot(squares)

# Interference shapes - can make them with: a boolean raster, directions = 8,
#    stopRule in place, spreadProb = 1
stopRule2 <- function(landscape) sum(landscape) > 200
squashedDiamonds <- spread(hab > 0, spreadProb = 1,
                           loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
                           directions = 4, id = TRUE, stopRule = stopRule2)
if (interactive()) {
  clearPlot()
  Plot(squashedDiamonds)
}

# Circles with spreadProb < 1 will give "more" circular shapes, but definitely not circles
stopRule2 <- function(landscape) sum(landscape) > 200
seed <- sample(1e4, 1)
set.seed(seed)
circlish <- spread(hab > 0, spreadProb = 0.23,
                   loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
                   directions = 8, id = TRUE, circle = TRUE)#, stopRule = stopRule2)
set.seed(seed)
regularCA <- spread(hab > 0, spreadProb = 0.23,
                    loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
                    directions = 8, id = TRUE)#, stopRule = stopRule2)
if (interactive()) {
  clearPlot()
  Plot(circlish, regularCA)
}

####################
# complex stopRule
####################

initialLoci <- sample(seq_len(ncell(hab)), 2)
endSizes <- seq_along(initialLoci) * 200

# Can be a function of landscape, id, and/or any other named
#   variable passed into spread
stopRule3 <- function(landscape, id, endSizes) sum(landscape) > endSizes[id]

TwoCirclesDiffSize <- spread(hab, spreadProb = 1, loci = initialLoci, circle = TRUE,
                             directions = 8, id = TRUE, stopRule = stopRule3,
                             endSizes = endSizes, stopRuleBehavior = "excludePixel")

# or using named list of named elements:
# TwoCirclesDiffSize <- spread(hab, spreadProb = 1, loci = initialLoci, circle = TRUE,
#                              directions = 8, id = TRUE, stopRule = stopRule3,
#                              vars = list(endSizes = endSizes), stopRuleBehavior = "excludePixel")

if (interactive()) {
  clearPlot()
  Plot(TwoCirclesDiffSize)
}
cirs <- getValues(TwoCirclesDiffSize)
vals <- tapply(hab[TwoCirclesDiffSize], cirs[cirs > 0], sum)

# Stop if sum of landscape is big or mean of quality is too small
quality <- raster(hab)
quality[] <- runif(ncell(quality), 0, 1)
stopRule4 <- function(landscape, quality, cells) {
  (sum(landscape) > 20) | (mean(quality[cells]) < 0.3)
}

TwoCirclesDiffSize <- spread(hab, spreadProb = 1, loci = initialLoci, circle = TRUE,
                             directions = 8, id = TRUE, stopRule = stopRule4,
                             quality = quality, stopRuleBehavior = "excludePixel")

##############
# allowOverlap
##############
set.seed(3113)
initialLoci <- as.integer(sample(1:ncell(hab), 10))

# using "landscape", "id", and a variable passed in
maxVal <- rep(500, length(initialLoci))

# define stopRule
stopRule2 <- function(landscape, id, maxVal) sum(landscape) > maxVal[id]
circs <- spread(hab, spreadProb = 1, circle = TRUE, loci = initialLoci, stopRule = stopRule2,
                id = TRUE, allowOverlap = TRUE, stopRuleBehavior = "includeRing",
                maxVal = maxVal, returnIndices = TRUE)
(vals <- tapply(hab[circs$indices], circs$id, sum))
vals <= maxVal ## all TRUE
overlapEvents <- raster(hab)
overlapEvents[] <- 0
toMap <- circs[, sum(id), by = indices]
overlapEvents[toMap$indices] <- toMap$V1

if (interactive()) {
  clearPlot()
  Plot(overlapEvents)
}


## Using alternative algorithm, not probabilistic diffusion
## Will give exactly correct sizes, yet still with variability
## within the spreading (i.e., cells with and without successes)
dev();
seed <- sample(1e6,1)
#seed <- 576534
set.seed(seed); print(seed)
startCells <- startCells[1:4]
maxSizes <- rexp(length(startCells), rate = 1 / 500)
fires <- spread(hab, loci = startCells, 1, persistence = 0,
                neighProbs = c(0.5, 0.5, 0.5) / 1.5,
                mask = NULL, maxSize = maxSizes, directions = 8,
                iterations = 1e6, id = TRUE, plot.it = FALSE, exactSizes = TRUE);
all(table(fires[fires > 0][]) == floor(maxSizes))

if (interactive()) {
  clearPlot()
  Plot(fires, new = TRUE, cols = c("red", "yellow"), zero.color = "white")
  Plot(hist(table(fires[][fires[] > 0])), title = "fire size distribution")
}

## Example with relativeSpreadProb ... i.e., a relative probability spreadProb
##  (shown here because because spreadProb raster is not a probability).
##  Here, we force the events to grow, choosing always 2 neighbours,
##  according to the relative probabilities
##  contained on hab layer. Note, neighProbs = c(0,1) forces each active pixel
##  to move to 2 new pixels (prob = 0 for 1 neighbour, prob = 1 for 2 neighbours)
##  Note: set hab3 to be very distinct probability differences, to detect spread
##  differences
hab3 <- (hab < 20) * 200 + 1
seed <- 643503
set.seed(seed)
sam <- sample(which(hab3[] == 1), 1)
set.seed(seed)
events1 <- spread(hab3, spreadProb = hab3, loci = sam, directions = 8,
             neighProbs = c(0, 1), maxSize = c(70), exactSizes = TRUE)
# Compare to absolute probability version
set.seed(seed)
events2 <- spread(hab3, id = TRUE, loci = sam, directions = 8,
                 neighProbs = c(0, 1), maxSize = c(70), exactSizes = TRUE)
if (interactive()) {
  clearPlot()
  Plot(events1, new = TRUE, cols = c("red", "yellow"), zero.color = "white")
  Plot(events2, new = TRUE, cols = c("red", "yellow"), zero.color = "white")
  Plot(hist(table(events1[][events1[] > 0]), breaks = 30), title = "Event size distribution")
# Check that events1 resulted in higher hab3 pixels overall
}
# Compare outputs -- should be more high value hab pixels spread to in event1
#  (randomness may prevent this in all cases)
hab3[events1[] > 0]
hab3[events2[] > 0]

sum(hab3[events1[] > 0]) >= sum(hab3[events2[] > 0]) ## should be usually TRUE
}
\seealso{
\code{\link{rings}} which uses \code{spreadDT} but with specific argument
values selected for a specific purpose. \code{\link[raster]{distanceFromPoints}}
}
\author{
Eliot McIntire

Steve Cumming
}
