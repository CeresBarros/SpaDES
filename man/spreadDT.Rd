% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spread-dt.R
\docType{methods}
\name{spreadDT}
\alias{spreadDT}
\alias{spreadDT,RasterLayer-method}
\title{Simulate a contagious spread process on a landscape, with data.table internals}
\usage{
spreadDT(landscape, start = ncell(landscape)/2 - ncol(landscape)/2,
  spreadProb = 0.23, asRaster = TRUE, maxSize, exactSize, directions = 8L,
  iterations = 1000000L, returnDistances = FALSE, plot.it = FALSE,
  circle = FALSE, allowOverlap = FALSE, neighProbs = NA_real_,
  skipChecks = FALSE)

\S4method{spreadDT}{RasterLayer}(landscape, start = ncell(landscape)/2 -
  ncol(landscape)/2, spreadProb = 0.23, asRaster = TRUE, maxSize, exactSize,
  directions = 8L, iterations = 1000000L, returnDistances = FALSE,
  plot.it = FALSE, circle = FALSE, allowOverlap = FALSE,
  neighProbs = NA_real_, skipChecks = FALSE)
}
\arguments{
\item{landscape}{A \code{RasterLayer} object. This defines the possible locations
for spreading events to start and spreadDT into. Required.}

\item{start}{Either a vector of pixel numbers to initiate spreading, or a
data.table that is the output of a previous \code{spreadDT}.
If a vector, they should be cell indices (pixels) on the \code{landscape}.
If user has x and y coordinates, these can be converted with
\code{\link[raster]{cellFromXY}}.}

\item{spreadProb}{Numeric or rasterLayer. If numeric of length 1, then this is
the global probability of
spreading into each cell from a neighbor. If a raster then this must
be the cell-specific probability of a "receiving" potential cell.
Default is \code{0.23}.}

\item{asRaster}{Logical, length 1. If \code{TRUE}, the function will return a \code{Raster}
where raster non NA values indicate the cells that were "actived", and the
value is the initial starting pixel.}

\item{maxSize}{Numeric. Maximum number of cells for a single or
all events to be spreadDT. Recycled to match \code{start} length,
if it is not as long as \code{start}. This will be overridden if
\code{exactSize} also provided.
See section on \code{Breaking out of spreadDT events}.}

\item{exactSize}{Numeric vector, length 1 or \code{length(start)}.
Similar to \code{maxSize}, but these will be the exact
final sizes of the events.  i.e., the spreadDT events
will continue until they are \code{floor(exactSize)}.
This will override \code{maxSize} if both provided.
See Details.}

\item{directions}{The number adjacent cells in which to look;
default is 8 (Queen case). Can only be 4 or 8.}

\item{iterations}{Number of iterations to spreadDT.
Leaving this \code{NULL} allows the spreadDT to continue
until stops spreading itself (i.e., exhausts itself).}

\item{returnDistances}{Logical. Should the function inclue a column with the
individual cell distances from the locus where that event
started. Default is FALSE. See Details.}

\item{plot.it}{If TRUE, then plot the raster at every iteraction,
so one can watch the spreadDT event grow.}

\item{circle}{Logical. If TRUE, then outward spreadDT will be by equidistant rings,
rather than solely by adjacent cells (via \code{directions} arg.). Default
is FALSE. Using \code{circle = TRUE} can be dramatically slower for large
problems. Note, this will likely create unexpected results if \code{spreadProb} < 1.}

\item{allowOverlap}{Logical. If \code{TRUE}, then individual events can overlap with one
another, i.e., they do not interact. Currently, this is slower than
if \code{allowOverlap} is \code{FALSE}. Default is \code{FALSE}.}

\item{neighProbs}{An optional numeric vector, whose sum is 1. It indicates the
probabilities that an individual
spread iteration will spread to \code{1, 2, ..., length(neighProbs)}
neighbours, respectively. If this is used (i.e., something other than
NA), \code{circle} and \code{returnDistances} will not work currently.}

\item{skipChecks}{Logical. If TRUE, the argument checking (i.e., assertions) will be
skipped. This should likely only be used once it is clear that the function
arguments are well understood and function speed is of the primary improtance.
This is likely most useful in repeated iteration cases i.e., if this call
is using the previous output from this same function.}
}
\value{
Either a \code{data.table} (\code{asRaster=FALSE}) or a \code{RasterLayer}
(\code{asRaster=TRUE}, the default). The \code{data.table} will have one attribute named
"cluster" as it provides cluster-level or event-level information about the
spread events. If \code{asRaster} is TRUE, then the \code{data.table} will be attached
to the Raster as an attribute named "pixel" as it provides pixel-level information about
the spread events.

The \code{RasterLayer} represents every cell in which a successful spreadDT event occurred.
For the case of, say, a fire this would represent every cell that burned.
If \code{allowOverlap} is \code{TRUE}, the return will always be a \code{data.table}.

If \code{asRaster} is \code{FALSE}, then this function returns a
\code{data.table} with columns:

\tabular{ll}{
  \code{initialPixels} \tab the initial cell number of that particular
                           spreadDT event.\cr
  \code{pixels} \tab The cell indices of cells that have
                       been touched by the spreadDT algorithm.\cr
  \code{state} \tab a logical indicating whether the cell is active (i.e.,
                       could still be a source for spreading) or not (no
                       spreading will occur from these cells).\cr
}

The attribute saved with the name "cluster" (e.g., \code{attr(output, "cluster")}) is
a \code{data.table} with columns:
\tabular{ll}{
  \code{id} \tab An arbitrary code, from 1 to \code{length(start)} for each "event".\cr
  \code{initialPixels} \tab the initial cell number of that particular
                           spreadDT event.\cr
  \code{numRetries} \tab The number of re-starts the event did because it got
                         stuck (normally only because \code{exactSize} was used
                         and was not achieved.\cr
  \code{maxSize} \tab The number of pixels that were provided as inputs via
                     \code{maxSize} or \code{exactSize}.\cr
  \code{size} \tab The current size, in pixels, of each event.\cr
}
}
\description{
This can be used to simulate fires, seed dispersal, calculation of iterative,
concentric, symmetric (currently) landscape values and many other things.
Essentially, it starts from a collection of cells (\code{start}, called "events")
and spreads to neighbours, according to the \code{directions}
and \code{spreadProb} with modifications due to other arguments.
}
\details{
There are 2 main underlying algorithms for active cells to "spread" to
nearby cells (adjacent cells): \code{spreadProb} and \code{neighProb}.
Using \code{spreadProb}, every "active" pixel will assess all
neighbours (either 4 or 8, depending on  \code{directions}), and will "activate"
whichever neighbours successfully pass independent calls to
\code{runif(1,0,1)<spreadProb}.
The algorithm will iterate again and again, each time starting from the newly
"activated" cells. Several built-in decisions are as follows.
1. no active cell can active a cell that was already activated by
the same event (i.e., "it won't go backwards"). 2. If \code{allowOverlap} is
\code{FALSE}, then the previous rule will also apply, regardless of which
"event" caused the pixels to be previously active.

This function can be interrupted before all active cells are exhausted if
the \code{iterations} value is reached before there are no more active
cells to spreadDT into. The interrupted output (a data.table) can be passed
subsequently as an input to this same function (as \code{start}).
This is intended to be used for situations where external events happen during
a spreadDT event, or where one or more arguments to the spreadDT function
change before a spreadDT event is completed.
For example, if it is desired that the \code{spreadProb} change before a
spreadDT event is completed because, for example, a fire is spreading, and a
new set of conditions arise due to a change in weather.



If \code{exactSize} or \code{maxSize} are used, then spreading will continue and stop
before or at \code{maxSize} or at \code{exactSize}. If \code{iterations} is specified,
then the function will end, and the returned \code{data.table} will still
may (if \code{maxSize}) or will (if \code{exactSize}) have at least one active
cell per event that did not already achieve \code{maxSize} or \code{exactSize}. This
will be very useful to build new, customized higher-level wrapper functions that iteratively
call \code{spreadDT}.
}
\note{
\code{exactSize} may not be achieved if there aren't enough cells in the map. Also,
\code{exactSize} may not be achieved because 2) the active cells are "stuck", i.e.,
they have no unactivated cells to move to or 3) the \code{spreadProb} is low. In the
latter 2 cases, the algorithm will retry again, but it will only re-try from the last
iterations active cells. The algorithm will only retry 10 times before quitting. Currently,
there will also be an attempt to "jump" up to 4 cells away from the active cells to
try to continue spreading.

A common way to use this function is to build wrappers around this, followed by iterative
calls in a \code{while} loop. See example.

When using this function iteratively, there are several things to be wary about. 1) The output
will likely be sorted differently than the input (i.e., the order of start, if a vector,
may not be the same order as that returned). This means that when passing the same object
back into the next iteration of the function call, \code{maxSize} or \code{exactSize} may
not be in the same order. To get the same order, use e.g.,
\code{maxSize=attr(out, "cluster")$maxSize}.
}
\section{Breaking out of spreadDT events}{


There are 3 ways for the spreadDT to "stop" spreading.
Here, each "event" is defined as all cells that are spawned from each unique
\code{start} location.
So, one spreadDT call can have multiple spreading "events".
The ways outlined below are all acting at all times, i.e., they are not
mutually exclusive.
Therefore, it is the user's responsibility to make sure the different rules
are interacting with each other correctly.

\tabular{ll}{
  \code{spreadProb} \tab Probabilistically, if spreadProb is low enough,
                         active spreading events will stop. In practice,
                         active spreading events will stop. In practice,
                         this number generally should be below 0.3 to actually
                         see an event stop\cr
  \code{maxSize} \tab This is the number of cells that are "successfully" turned
                      on during a spreading event. This can be vectorized, one value
                      for each event   \cr
  \code{iterations} \tab This is a hard cap on the number of internal iterations to
                         complete before returning the current state of the system
                         as a data.table \cr
}
}

\examples{
library(raster)

a <- raster(extent(0, 10 , 0, 10), res = 1)
sams <- sort(sample(ncell(a), 3))

# Simple use -- similar to spread(...)
out <- spreadDT(a, start = sams, 0.225)
if(interactive()) {
  clearPlot()
  Plot(out)
}

# Use maxSize -- this gives an upper limit
maxSizes <- sort(sample(1:10, size = length(sams)))
out <- spreadDT(a, start = sams, 0.225, maxSize = maxSizes, asRaster=FALSE)
# check TRUE using data.table .N
out[,.N,by="initialPixels"]$N <= maxSizes

# Use exactSize -- gives an exact size, if there is enough space on the Raster
exactSizes <- maxSizes
out <- spreadDT(a, start = sams, spreadProb = 0.225,
                exactSize = exactSizes, asRaster=FALSE)
out[,.N,by="initialPixels"]$N == maxSizes # should be TRUE TRUE TRUE

# Use exactSize -- but where it can't be achieved
exactSizes <- sort(sample(100:110, size = length(sams)))
out <- spreadDT(a, start = sams, 1, exactSize = exactSizes)

# Iterative calling -- create a function with a high escape probability
spreadWithEscape <- function(ras, start, escapeProb, spreadProb) {
  out <- spreadDT(ras, start = sams, spreadProb = escapeProb, asRaster = FALSE)
  while(any(out$state=="sourceActive")) {
    # pass in previous output as start
    out <- spreadDT(ras, start = out, spreadProb = spreadProb,
                    asRaster = FALSE, skipChecks = TRUE) # skipChecks for speed
  }
  out
}

set.seed(421)
out1 <- spreadWithEscape(a, sams, escapeProb = 0.25, spreadProb = 0.225)
set.seed(421)
out2 <- spreadDT(a, sams, 0.225, asRaster = FALSE)
# The one with high escape probability is larger (most of the time)
NROW(out1)>NROW(out2)


## Use neighProbs, with a spreadProb that is a RasterLayer
# Create a raster of different values, which will be the relative probabilities
#   i.e., they are rescaled to relative probabilities within the 8 neighbour choices.
#   The neighProbs below means 70\% of the time, 1 neighbour will be chosen,
#   30\% of the time 2 neighbours.
#   The cells with spreadProb of 5 are 5 times more likely than cells with 1 to be chosen,
#   when they are both within the 8 neighbours
sp <- raster(extent(0,3,0,3), res = 1, vals = 1:9) #small raster, simple values
# Check neighProbs worked
out <- list()
for(i in 1:100) { # enough replicates to see stabilized probabilities
  out[[i]] <- spreadDT(sp, spreadProb = sp, start = 5, iterations = 1,
                neighProbs = c(1), asRaster = FALSE)
}
out <- data.table::rbindlist(out)[pixels!=5] # remove starting cell
table(sp[out$pixels])
# should be non-significant
chisq.test(c(1:4,6:9), unname(table(sp[out$pixels])), simulate.p.value = TRUE)
}
\seealso{
\code{\link{rings}} which uses \code{spreadDT} but with specific argument
values selected for a specific purpose. \code{\link[raster]{distanceFromPoints}}
}
\author{
Eliot McIntire

Steve Cumming
}
