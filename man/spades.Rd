% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation.R, R/parallel.R
\docType{methods}
\name{spades}
\alias{experiment}
\alias{experiment,simList-method}
\alias{spades}
\alias{spades,simList,logical-method}
\alias{spades,simList,missing-method}
\title{Run a spatial discrete event simulation}
\usage{
spades(sim, debug)

\S4method{spades}{simList,logical}(sim, debug)

\S4method{spades}{simList,missing}(sim)

experiment(sim, replicates = 1, params = list(), modules = list(),
  objects = list(), inputs = list(), dirPrefix = "simNum",
  substrLength = 3, ...)

\S4method{experiment}{simList}(sim, replicates = 1, params = list(),
  modules = list(), objects = list(), inputs = list(),
  dirPrefix = "simNum", substrLength = 3, ...)

\S4method{spades}{simList,missing}(sim)
}
\arguments{
\item{sim}{A \code{simList} simulation object, generally produced by \code{simInit}.}

\item{debug}{Optional logical flag determines whether sim debug info
will be printed (default is \code{debug=FALSE}).}

\item{replicates}{The number of replicates to run of the same \code{simList}}

\item{params}{A named list of simulation parameters and their values.}

\item{modules}{A named list of character strings specfying the names
of modules to be loaded for the simulation. Note: the module name
should correspond to the R source file from which the module is loaded.
Example: a module named "caribou" will be sourced form the file
\file{caribou.R}, located at the specified \code{modulePath(simList)} (see below).}

\item{objects}{An optional list of data objects to be used in the simulation.}

\item{inputs}{A \code{data.frame}. Can specify from 1 to 6
columns with following column names: \code{objectName} (character, required),
\code{file} (character), \code{fun} (character), \code{package} (character),
\code{interval} (numeric), \code{loadTime} (numeric).
See \code{\link{inputs}} and vignette("ii-modules") section about inputs.}

\item{substrLength}{For outputPath, how many characters should be kept from each factor level. See Details.}
}
\value{
Invisibly returns the modified \code{simList} object.

Invisibly returns all resulting \code{simList} objects from the fully factorial experiment.
Since this may be large, the user is not obliged to return this object (as it is returned invisibly).
Any objects that are desired as outputs, will be contained within these
}
\description{
Based on code from chapter 7.8.3 of Matloff (2011): "Discrete event simulation".
Here, we implement a simulation in a more modular fashion so it's easier to add
submodules to the simulation. We use S4 classes and methods, and use `data.table`
instead of `data.frame` to implement the event queue (because it is much faster).

This is essentially a wrapper around the \code{spades} call that allows for
parameters or modules to vary. This function will create a fully factorial experiment
among all levels of the variables passed into the function. The function
requires a \code{simList} object, plus optional params and/or modules and/or replications.
}
\details{
This function takes a simList where the majority of parameters are defined, and changes
a few, passed as arguments here, to create a fully factorial experiment.

There are a few behaviours that are assumed:

- outputPath is updated to include a subdirectory with names identifying which values of parameters
were used. This subdirectory could be long if there are lots of dimensions to the experiment.

When making sub directories for saving outputs, in order for the filenames to be meaningful (the default),
the module(s) are listed, and the parameter names and the parameter values. This can become very long. To
truncate these names to shorter, manageable lengths, \code{substrLength} can be used, and it represents the length
of each character string (module name, parameter name) is truncated to. The resulting directory name would be, say
psprea_0.225-N_10 if \code{substrLength} is 6, the default.
}
\note{
The debug option is primarily intended to facilitate building simulation
models by the user. Will print additional outputs informing the user of updates
to the values of various simList slot components.
}
\examples{
\dontrun{
 mySim <- simInit(
   times = list(start = 0.0, end = 2.0, timeunit = "year"),
   params = list(
     .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
   ),
   modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
   paths = list(modulePath = system.file("sampleModules", package = "SpaDES"))
 )
 spades(mySim)
}

\dontrun{

 library(raster)
 beginCluster(10)

# Example of changing parameter values
 mySim <- simInit(
   times = list(start = 0.0, end = 2.0, timeunit = "year"),
   params = list(
     .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
     # Turn off interactive plotting
     fireSpread = list(.plotInitialTime=NA),
     caribouMovement = list(.plotInitialTime=NA),
     randomLandscapes = list(.plotInitialTime=NA)
   ),
   modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
   paths = list(modulePath = system.file("sampleModules", package = "SpaDES"),
                outputPath = tempdir()),
   # Save final state of landscape and caribou
   outputs = data.frame(objectName=c("landscape", "caribou"), stringsAsFactors=FALSE)
 )


 # Create an experiment - here, 2 x 2 x 2 (2 levels of 2 params in fireSpread,
 #    and 2 levels of 1 param in caribouMovement)
 experimentParams <- list(fireSpread = list(spreadprob = c(0.2, 0.23),
                                             nFires = c(20, 10)),
                       caribouMovement = list(N = c(100, 1000)))

 sims <- experiment(mySim, params=experimentParams)

 # Read in outputs from sims object
 FireMaps = do.call(stack, lapply(1:NROW(attr(sims,"experiment")), function(x) sims[[x]]$landscape$Fires))
 Plot(FireMaps, new=TRUE)

 # Or reload objects from files, useful if sim objects too large to store in RAM
 caribouMaps <- lapply(sims, function(sim) {
   caribou <- readRDS(outputs(sim)$file[outputs(sim)$objectName=="caribou"])
   }
 )
 names(caribouMaps) <- paste0("caribou",1:8)
 # Plot does not plot whole lists (yet)
 Plot(caribouMaps[[1]], caribouMaps[[2]], caribouMaps[[3]], caribouMaps[[4]],
      caribouMaps[[5]], caribouMaps[[6]], caribouMaps[[7]], caribouMaps[[8]],
      size=0.1)
 endCluster()

#######
# Example of changing modules, i.e., caribou with and without fires
 # Create an experiment - here, 2 x 2 x 2 (2 levels of 2 params in fireSpread,
 #    and 2 levels of 1 param in caribouMovement)
 experimentModules <- list(
     c("randomLandscapes", "fireSpread", "caribouMovement"),
     c("randomLandscapes", "caribouMovement")
     )

 sims <- experiment(mySim, modules=experimentModules, params=experimentParams)

 # Read in outputs from sims object
 FireMaps = do.call(stack, lapply(1:8, function(x) sims[[x]]$landscape$Fires))
 Plot(FireMaps, new=TRUE)

 # Or reload objects from files, useful if sim objects too large to store in RAM
 caribouMaps <- lapply(sims, function(sim) {
   caribou <- readRDS(outputs(sim)$file[outputs(sim)$objectName=="caribou"])
   }
 )
 names(caribouMaps) <- paste0("caribou",1:8)
 # Plot does not plot whole lists (yet)
 Plot(caribouMaps[[1]], caribouMaps[[2]], caribouMaps[[3]], caribouMaps[[4]],
      caribouMaps[[5]], caribouMaps[[6]], caribouMaps[[7]], caribouMaps[[8]],
      size=0.1)

 # manipulate directory names
 sims <- experiment(mySim, params=experimentParams, dirPrefix=c("expt", "simNum"))

 # doing replicate runs - THESE TAKE SOME TIME (minutes if not using a cluster)
 sims <- experiment(mySim, replicates = 10)
 # putting them in a subdirectory
 sims <- experiment(mySim, replicates = 10, dirPrefix = c("expt"))

 # Both replication and experiment, both params and modules
 # use a sub directory
 outputPath(mySim) <- file.path(tempdir(), "myExpt3")
 sims <- experiment(mySim, replicates = 5, modules=experimentModules,
                    params=experimentParams, dirPrefix=c("expt", "simNum"))



 # Use replication to build a probability surface, here, need to provide a fixed landscape
 # Step 1 - run randomLandscapes once to get a landscape map
 mySim <- simInit(
   times = list(start = 0.0, end = 0.1, timeunit = "year"),
   params = list(
     .globals = list(stackName = "landscape"),
     # Turn off interactive plotting
     fireSpread = list(.plotInitialTime=NA)
   ),
   modules = list("randomLandscapes"),
   paths = list(modulePath = system.file("sampleModules", package = "SpaDES"),
                outputPath = tempdir()),
 )
 mySim <- spades(mySim)  # Run it
 #extract the landscape, which will be passed into next as an object
 landscape <- mySim$landscape

 mySim <- simInit(
   times = list(start = 0.0, end = 1, timeunit = "year"),
   params = list(
     .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
     # Turn off interactive plotting
     fireSpread = list(.plotInitialTime=NA),
     caribouMovement = list(.plotInitialTime=NA)
   ),
   modules = list("fireSpread", "caribouMovement"), # No randomLandscapes modules
   paths = list(modulePath = system.file("sampleModules", package = "SpaDES"),
                outputPath = tempdir()),
   objects = c("landscape"), # Pass in the object here
   # Save final state of landscape and caribou
   outputs = data.frame(objectName=c("landscape", "caribou"), stringsAsFactors=FALSE)
 )

 outputPath(mySim) <- file.path(tempdir(), "myExpt6")
 sims <- experiment(mySim, replicates = 50) # Run experiment
 attr(sims, "experiment") # shows the experiment, which in this case is just replicates
 # list all files that were saved called 'landscape'
 files1 <- dir(outputPath(mySim), recursive=TRUE, pattern="landscape", full.names=TRUE)
 # Read them in - alternatively, this could use the sims object directly also, e.g., sims[[1]]$landscape$Fires
 landscapes <- lapply(files1, readRDS)
 fires1 <- do.call(stack, lapply(landscapes, function(x) x$Fires)) # Extract just Fire layer
 fires1[fires1>0] <- 1 # convert to 1s and 0s
 fireProb <- sum(fires1)/nlayers(fires1) # sum them and convert to probability
 Plot(fireProb, new=TRUE)

 endCluster()
 library(magrittr)
 dir(file.path(tempdir()), pattern="myExpt[.]*", full.names=TRUE) \%>\%
   unlink(recursive=TRUE)
}

}
\author{
Alex Chubaty

Eliot McIntire
}
\references{
Matloff, N. (2011). The Art of R Programming (ch. 7.8.3). San Fransisco, CA: No Starch Press, Inc.. Retrieved from \url{http://www.nostarch.com/artofr.htm}
}
\seealso{
\code{\link{simInit}}, \code{\link{SpaDES}}

\code{\link{simInit}}, \code{\link{SpaDES}}
}

