% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/neighbourhood.R
\docType{methods}
\name{cir}
\alias{cir}
\alias{cir,RasterLayer,SpatialPoints,missing-method}
\alias{cir,RasterLayer,matrix,missing-method}
\alias{cir,RasterLayer,missing,missing-method}
\alias{cir,RasterLayer,missing,numeric-method}
\title{Identify pixels in a circle or ring (donut) around an object.}
\usage{
cir(landscape, coords, loci, maxRadius = ncol(landscape)/4,
  minRadius = maxRadius, allowOverlap = TRUE,
  includeBehavior = "includePixels", returnDistances = FALSE,
  returnAngles = FALSE, simplify = TRUE)

\S4method{cir}{RasterLayer,SpatialPoints,missing}(landscape, coords, maxRadius,
  minRadius = maxRadius, allowOverlap, includeBehavior, returnDistances,
  returnAngles, simplify)

\S4method{cir}{RasterLayer,missing,numeric}(landscape, loci, maxRadius,
  minRadius = maxRadius, allowOverlap, includeBehavior, returnDistances,
  returnAngles, simplify)

\S4method{cir}{RasterLayer,missing,missing}(landscape, loci, maxRadius,
  minRadius = maxRadius, allowOverlap, includeBehavior, returnDistances,
  returnAngles, simplify)

\S4method{cir}{RasterLayer,matrix,missing}(landscape, coords, loci,
  maxRadius = ncol(landscape)/4, minRadius = maxRadius,
  allowOverlap = TRUE, includeBehavior = "includePixels",
  returnDistances = FALSE, returnAngles = FALSE, simplify = TRUE)
}
\arguments{
\item{landscape}{Raster on which the circles are built.}

\item{coords}{Either a matrix with 2 columns, x and y, representing the coordinates
or a \code{SpatialPoints*} object around which to make circles. Must be same
coordinate system as the \code{landscape} argument. Default is missing,
meaning it uses the default to \code{loci}}

\item{loci}{Numeric. An alternative to \code{coords}. These are the indices on
\code{landscape} to initiate this function. See \code{coords}. Default is one
point in centre of \code{landscape}..}

\item{maxRadius}{Numeric vector of length 1 or same length as coords}

\item{minRadius}{Numeric vector of length 1 or same length as \code{coords}. Default is
\code{maxRadius}, meaning return all cells that are touched
by the narrow ring at that exact radius. If smaller than \code{maxRadius},
then this will create a buffer or donut or ring.}

\item{allowOverlap}{Logical. Should duplicates across eventID be removed or kept. Default TRUE.}

\item{includeBehavior}{Character string. Currently accepts only "includePixels", the default,
and "excludePixels". See details.}

\item{returnDistances}{Logical. If TRUE, then a column will be added to the returned
data.table that reports the distance from \code{coords} to every
point that was in the circle/donut surrounding \code{coords}. Default
FALSE, which is faster.}

\item{returnAngles}{Logical. If TRUE, then a column will be added to the returned
data.table that reports the angle from \code{coords} to every
point that was in the circle/donut surrounding \code{coords}. Default
FALSE.}

\item{simplify}{logical. If TRUE, then all duplicate pixels are removed. This means
that some x, y combinations will disappear.}
}
\value{
A \code{matrix} with 4 columns, \code{eventID}, \code{indices},
\code{x}, \code{y}. The \code{x} and \code{y} indicate the
exact coordinates of
the \code{indices} (i.e., cell number) of the \code{landscape}
associated with the ring or circle being identified by this function.
}
\description{
Identify the pixels and coordinates that are at
 a (set of) buffer distance(s) of the objects passed into \code{coords}. This is similar
 to \code{\link[rgeos]{gBuffer}} but much faster and without the georeferencing information.
 In other words, it can be used for similar problems, but where speed is important.
}
\details{
This function identifies all the pixels as defined by a donut
with inner radius minRadius and outer radius of maxRadius. The includeBehavior defines
whether the cells that intersect the radii but whose centres are not inside
the donut are included \code{includePixels} or not \code{excludePixels} in the returned
pixels identified. If this is \code{excludePixels}, and if a \code{minRadius} and
\code{maxRadius} are equal, this will return no pixels.
}
\examples{
library(raster)
library(data.table)
library(sp)

# circle centred
Ras <- raster(extent(0, 15, 0, 15), res = 1)
Ras[] <- 0
middleCircle <- cir(Ras)
Ras[middleCircle[,"indices"]] <- 1
Plot(Ras, new=TRUE)
circlePoints <- SpatialPoints(middleCircle[,c("x","y")])
Plot(circlePoints, addTo = "Ras")

# circles non centred
Ras <- randomPolygons(Ras, numTypes = 4)
N <- 2
caribou <- SpatialPoints(coords = cbind(x = stats::runif(N, xmin(Ras), xmax(Ras)),
                                        y = stats::runif(N, xmin(Ras), xmax(Ras))))
cirs <- cir(Ras, caribou, maxRadius = 3, simplify = TRUE)
cirsSP <- SpatialPoints(coords = cirs[, c("x", "y")])
cirsRas <- raster(Ras)
cirsRas[] <- 0
cirsRas[cirs[, "indices"]] <- 1
Plot(Ras, new = TRUE)
Plot(cirsRas, addTo = "Ras", cols = c("transparent", "#00000055"))
Plot(caribou, addTo = "Ras")
Plot(cirsSP, addTo = "Ras")

# Example comparing rings and cir
a <- raster(extent(0,30,0,30), res = 1)
hab <- gaussMap(a,speedup = 1) # if raster is large (>1e6 pixels), use speedup>1
radius <- 4
N = 2
caribou <- SpatialPoints(coords = cbind(x = stats::runif(N, xmin(hab), xmax(hab)),
                                        y = stats::runif(N, xmin(hab), xmax(hab))))

# cirs
cirs <- cir(hab, caribou, maxRadius = rep(radius, length(caribou)), simplify = TRUE)

# rings
loci <- cellFromXY(hab, coordinates(caribou))
cirs2 <- rings(hab, loci, maxRadius = radius, minRadius=radius-1)

# Plot both
ras1 <- raster(hab)
ras1[] <- 0
ras1[cirs[,"indices"]] <- cirs[,"eventID"]
Plot(ras1, new=TRUE)

ras2 <- raster(hab)
ras2[] <- 0
ras2[cirs2$indices] <- cirs2$eventID
Plot(ras2)

a <- raster(extent(0,100,0,100), res = 1)
hab <- gaussMap(a,speedup = 1)
cirs <- cir(hab, caribou, maxRadius = 44, minRadius = 0)
ras1 <- raster(hab)
ras1[] <- 0
cirsOverlap <- data.table(cirs)[,list(sumIDs = sum(eventID)),by=indices]
ras1[cirsOverlap$indices] <- cirsOverlap$sumIDs
Plot(ras1, new=TRUE)

# using loci instead of coords
cirs <- cir(hab, loci = 4550, maxRadius = 14, minRadius = 0)
ras1[] <- 0
ras1[cirs[,"indices"]] <- cirs[,"eventID"]
Plot(ras1, new=TRUE)

}
\seealso{
\code{\link{rings}} which uses \code{spread} under internally, but it
is generally slower. One difference
between the two functions is that \code{rings} takes the centre of the pixel
as the centre of a circle, whereas \code{cir} takes the exact coordinates.
See example.
\code{\link[rgeos]{gBuffer}}
}

