% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/neighbourhood.R
\docType{methods}
\name{cir}
\alias{cir}
\alias{cir,SpatialPoints-method}
\alias{cir,matrix-method}
\title{Identify pixels in a circle or ring (donut) around an object.}
\usage{
cir(coords, maxRadius, raster, minRadius = maxRadius, allowOverlap = TRUE,
  includeBehavior = "includePixels", simplify = TRUE)

\S4method{cir}{SpatialPoints}(coords, maxRadius, raster,
  minRadius = maxRadius, allowOverlap = TRUE,
  includeBehavior = "includePixels", simplify = TRUE)

\S4method{cir}{matrix}(coords, maxRadius, raster, minRadius = maxRadius,
  allowOverlap = TRUE, includeBehavior = "includePixels", simplify = TRUE)
}
\arguments{
\item{coords}{Either a matrix with 2 columns, x and y, representing the coordinates
or a SpatialPoints* object around which to make circles. Must be same
coordinate system as the \code{raster} argument.}

\item{maxRadius}{Numeric vector of length 1 or same length as coords}

\item{raster}{Raster on which the circles are built.}

\item{minRadius}{Numeric vector of length 1 or same length as \code{coords}. Default is
\code{maxRadius}, meaning return all cells that are touched
by the narrow ring at that exact radius. If smaller than \code{maxRadius},
then this will create a buffer or donut or ring.}

\item{allowOverlap}{Logical. Should duplicates across eventID be removed or kept. Default TRUE.}

\item{includeBehavior}{Character string. Currently accepts only "includePixels", the default,
and "excludePixels"}

\item{simplify}{logical. If TRUE, then all duplicate pixels are removed. This means
that some x, y combinations will disappear}
}
\value{
A \code{data.table} with 5 columns, \code{eventID}, \code{pixelIDs},
\code{rasterVal}, \code{x}, \code{y}. The \code{x} and \code{y} indicate the
coordinates of each
unique pixel of the circle around each individual.
}
\description{
Identify the pixels and coordinates that are at
 a (set of) buffer distance(s) of the objects passed into \code{coords}.
}
\examples{
library(raster)
library(sp)

Ras <- raster(extent(0, 15, 0, 15), res = 1)
Ras <- randomPolygons(Ras, numTypes = 4, speedup = 1, p = 0.3)
N <- 2
caribou <- SpatialPoints(coords = cbind(x = stats::runif(N, xmin(Ras), xmax(Ras)),
                                        y = stats::runif(N, xmin(Ras), xmax(Ras))))
cirs <- cir(caribou, 3, Ras, simplify = TRUE)
cirsSP <- SpatialPoints(coords = cirs[, list(x, y)])
cirsRas <- raster(Ras)
cirsRas[] <- 0
cirsRas[cirs[, indices]] <- 1
Plot(Ras, new = TRUE)
Plot(cirsRas, addTo = "Ras", cols = c("transparent", "#00000055"))
Plot(caribou, addTo = "Ras")
Plot(cirsSP, addTo = "Ras")

# Example comparing rings and cir
a <- raster(extent(0,30,0,30), res = 1)
hab <- gaussMap(a,speedup = 1) # if raster is large (>1e6 pixels), use speedup>1
radius <- 4
N = 2

caribou <- SpatialPoints(coords = cbind(x = stats::runif(N, xmin(hab), xmax(hab)),
                                        y = stats::runif(N, xmin(hab), xmax(hab))))

# cirs
cirs <- cir(caribou, rep(radius, length(caribou)), hab, simplify = TRUE)

# rings
loci <- cellFromXY(hab, coordinates(caribou))
cirs2 <- rings(hab, loci, maxD = radius, minD=radius-1)

# Plot both
ras1 <- raster(hab)
ras1[] <- 0
ras1[cirs$indices] <- cirs$eventID
Plot(ras1)

ras2 <- raster(hab)
ras2[] <- 0
ras2[cirs2$indices] <- cirs2$eventID
Plot(ras2)

a <- raster(extent(0,100,0,100), res = 1)
hab <- gaussMap(a,speedup = 1)
cirs <- cir(caribou, maxRadius = 44, hab, minRadius = 0)
ras1 <- raster(hab)
ras1[] <- 0
cirsOverlap <- cirs[,list(sumIDs = sum(eventID)),by=indices]
ras1[cirsOverlap$indices] <- cirsOverlap$sumIDs
Plot(ras1, new=TRUE)
}
\seealso{
\code{\link{rings}} which is more flexible, allowing for different
widths of rings, for example, but it is generally slower. One difference
between the two functions is that \code{rings} takes the centre of the pixel
as the centre of the circle, whereas \code{cir} takes the exact coordinates.
See example.
}

