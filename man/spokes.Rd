% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/neighbourhood.R
\docType{methods}
\name{stopRule}
\alias{spokes}
\alias{spokes,RasterLayer,SpatialPoints,missing-method}
\alias{stopRule}
\title{Identify outward radiating spokes from initial points}
\usage{
stopRule(landscape)

spokes(landscape, coords, loci, maxRadius = ncol(landscape)/4,
  minRadius = maxRadius, allowOverlap = TRUE, stopRule = NULL,
  includeBehavior = "includePixels", returnDistances = FALSE,
  angles = NA_real_, nAngles = NA_real_, returnAngles = FALSE,
  returnIndices = TRUE)

\S4method{spokes}{RasterLayer,SpatialPoints,missing}(landscape, coords, loci,
  maxRadius, minRadius = maxRadius, allowOverlap, stopRule, includeBehavior,
  returnDistances, angles, returnAngles, returnIndices)
}
\arguments{
\item{landscape}{Raster on which the circles are built.}

\item{coords}{Either a matrix with 2 (or 3) columns, x and y (and id), representing the
coordinates (and an associated id, like cell index),
or a \code{SpatialPoints*} object around which to make circles. Must be same
coordinate system as the \code{landscape} argument. Default is missing,
meaning it uses the default to \code{loci}}

\item{loci}{Numeric. An alternative to \code{coords}. These are the indices on
\code{landscape} to initiate this function. See \code{coords}. Default is one
point in centre of \code{landscape}..}

\item{maxRadius}{Numeric vector of length 1 or same length as coords}

\item{minRadius}{Numeric vector of length 1 or same length as \code{coords}. Default is
\code{maxRadius}, meaning return all cells that are touched
by the narrow ring at that exact radius. If smaller than \code{maxRadius},
then this will create a buffer or donut or ring.}

\item{allowOverlap}{Logical. Should duplicates across id be removed or kept. Default TRUE.}

\item{stopRule}{A function. If the spokes are to stop based on some feature of the
\code{landscape}. See examples.}

\item{includeBehavior}{Character string. Currently accepts only "includePixels", the default,
and "excludePixels". See details.}

\item{returnDistances}{Logical. If TRUE, then a column will be added to the returned
data.table that reports the distance from \code{coords} to every
point that was in the circle/donut surrounding \code{coords}. Default
FALSE, which is faster.}

\item{angles}{Numeric. Optional vector of angles, in radians, to use. This will create
"spokes" outward from coords. Default is NA, meaning, use internally
derived angles that will "fill" the circle.}

\item{returnAngles}{Logical. If TRUE, then a column will be added to the returned
data.table that reports the angle from \code{coords} to every
point that was in the circle/donut surrounding \code{coords}. Default
FALSE.}

\item{returnIndices}{Logical. Should the function return a data.table with
indices and values of successful spread events, or
return a raster with values. See Details.}
}
\value{
A matrix containing columns id, angles, x, y, indices, and dists.
}
\description{
This is a generalized version of a notion of a viewshed. The main difference
is that there can be many "viewpoints".
}
\examples{
library(raster)
library(sp)
Ras <- raster(extent(0,50,0,50), res = 1, val = 0)
rp <- randomPolygons(Ras, numTypes = 20)
if(interactive())
  Plot(rp, new=TRUE)
angles <- seq(0,pi*2,length.out = 17)
angles <- angles[-length(angles)]
N <- 2
coords <- SpatialPoints(cbind(x = sample(ncol(Ras),N), y = sample(nrow(Ras),N)))
d2 <- spokes(rp, coords = coords,
             minRadius = 0, maxRadius = 13, returnAngles = TRUE, returnDistances = TRUE,
             allowOverlap = TRUE, angles = angles, returnIndices = TRUE)

rasB <- raster(Ras)
rasB[] <- 0
rasB[d2[,"indices"]] <- 1
if(interactive()) {
  if(NROW(d2)>0) {
    sp1 <- SpatialPoints(d2[,c("x",'y')])
    Plot(sp1, addTo="rp", pch = 19, size = 1)
  }
  Plot(coords, addTo="rp", pch = 19, size = 4, cols = "blue")
}
}
\author{
Eliot McIntire
}

