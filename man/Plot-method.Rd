% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/plotting.R
\docType{methods}
\name{Plot}
\alias{Plot}
\alias{Plot,spadesPlotObjects-method}
\title{Plot: Fast, optimally arranged, multipanel plotting function with SpaDES}
\usage{
Plot(..., new = FALSE, addTo = NULL, gp = gpar(), axes = "L",
  speedup = 1, size = 5, cols = NULL, zoomExtent = NULL,
  visualSqueeze = 0.75, legend = TRUE, legendRange = NULL,
  legendText = NULL, draw = TRUE, pch = 19, title = TRUE,
  na.color = "#FFFFFF00", zero.color = "#FFFFFF00")

\S4method{Plot}{spadesPlotObjects}(..., new = FALSE, addTo = NULL,
  gp = gpar(), axes = "L", speedup = 1, size = 5, cols = NULL,
  zoomExtent = NULL, visualSqueeze = 0.75, legend = TRUE,
  legendRange = NULL, legendText = NULL, draw = TRUE, pch = 19,
  title = TRUE, na.color = "#FFFFFF00", zero.color = "#FFFFFF00")
}
\arguments{
\item{...}{\code{Raster*} object(s) and/or \code{SpatialPoints* objects}.
See details for naming.}

\item{new}{Logical. If \code{TRUE}, then the previous plot is wiped and a new one made;
if \code{FALSE}, then the \code{...} plots will be added to the current device,
adding or rearranging the plot layout as necessary. Default is \code{FALSE}.}

\item{addTo}{String vector, with same length as \code{...}.
This is for overplotting, when the overplot is not to occur on the plot with
the same name, such as plotting a \code{SpatialPoints*} object on a \code{RasterLayer}.}

\item{gp}{A gpar object, created by \code{\link{gpar}} function,
to change plotting parameters (see \code{\link{grid}} package).}

\item{axes}{Logical or \code{"L"}, representing the left and bottom axes, overall plots.}

\item{speedup}{Numeric. The factor by which the number of pixels is divided by to plot rasters.
See Details.}

\item{size}{Numeric. The size, in points, for \code{SpatialPoints} symbols,
if using a scalable symbol.}

\item{cols}{character vector or list of character vectors. Default \code{terrain.color()}. See Details.}

\item{zoomExtent}{extent object. Supplying a single extent object that is smaller than the
rasters will call a crop statement before plotting. Defaults to \code{NULL}.
This occurs after any downsampling of rasters, so it may produce very pixelated maps.}

\item{visualSqueeze}{numeric. The proportion of the white space to be used for plots. Default is 0.75.}

\item{legend}{logical. Whether legend should be drawn next to plots. Default is \code{TRUE}.}

\item{legendRange}{numeric vector giving values that, representing the lower
and upper bounds of a legend (i.e., 1:10 or c(1,10) will give same result)
that will override the data bounds contained within the \code{grobToPlot}.}

\item{legendText}{Vector of values to use for legend value labels.
Defaults to \code{NULL}, which results in a pretty numeric representation.
If \code{Raster*} has a Raster Attribute Table (rat; see \code{\link{raster}}
package), this will be used by default. Currently, only a single vector is accepted.}

\item{draw}{logical, whether to actually draw the plots.
Currently, there is no reason for this to be \code{FALSE}. Default is \code{TRUE}.}

\item{pch}{see \code{?par}.}

\item{title}{Logical. Whether the names of each plot should be written above plots.}

\item{na.color}{string indicating the color for \code{NA} values. Default transparent.}

\item{zero.color}{string indicating the color for zero values, when zero is
the minimum value, otherwise, zero is treated as any other color. Default transparent.}
}
\description{
The main plotting function accompanying \code{SpaDES}.
This can take objects of type \code{Raster*}, \code{SpatialPoints*},
\code{SpatialPolygons*}, and any combination of those.  It can
also handle \code{ggplot2} objects or base histogram objects via call to
\code{exHist <- hist(1:10, plot=F)}, but these non-spatial objects
cannot be mixed among types (i.e., can't mix and match spatial and
non-spatial objects, or base histogram and ggplot2 types). Customization of the
ggplot2 elements can be done as a normal ggplot2 plot, then added with
\code{Plot(ggplotObject)}
}
\details{
If \code{new=TRUE}, a new plot will be generated.
When \code{new=FALSE}, any plot that already exists will be overplotted,
while plots that have not already been plotted will be added.
This function rearranges the plotting device to maximize the size of all the
plots, minimizing white space.
If using the RStudio IDE, it is recommended to make and use a new device
(using \code{\link{dev}}), because the built in device is not made for rapid redrawing.
The function is based on the grid package.

Each panel in the multipanel plot must have a name.
This name is used to overplot, rearrange the plots, or overlay using
\code{addTo} when necessary.
If the \code{...} are named spadesPlotObjects, then \code{Plot} will use these names.
If not, then \code{Plot} will use the object name and the layer name (in the
case of \code{RasterLayer} or \code{RasterStack} objects).
If plotting a RasterLayer and the layer name is "layer" or the same as the object name,
then, for simplicity, only the object name will be used.
In other words, only enough information is used to uniquely identify the plot.

\code{cols} is a vector of colours that can be understood directly, or by
\code{colorRampePalette}, such as \code{c("orange", "blue")}, will give a colour range
from orange to blue, interploated. If a list, it will be used, in order, for each
item to be plotted. It will be recycled if it is shorter than the objects to be
plotted. Note that when this approach to setting colours is used, any overplotting
will revert to the \code{colortable} slot of the object, or the default for rasters,
which is \code{terrain.color()}

Silently, one hidden object is made, \code{.spadesArr} in the \code{.spadesEnv}
environment, which is used for arranging plots in the device window, and
identifying the objects to be replotted if rearranging is required, subsequent
to a \code{new=FALSE} additional plot.

This function is optimized to allow modular Plotting. This means that several
behaviours will appear unusual. For instance, if a first call to Plot is made,
the legend will reflect the current color scheme. If a second or subsequent call
to Plot is made with the same object but with different colours (e.g., with
\code{cols}), the legend will not update. This behaviour is made with the decision
that the original layer takes precedence and all subsequent plots to that same
frame are overplots only.

\code{speedup} is not a precise number because it is faster to plot an un-resampled
raster if the new resampling is close to the original number of pixels. At the moment,
this is set to 1/3 of the original pixels. In other words, \code{speedup} will not do
anything if the factor for speeding up is not high enough (i.e., >3).
}
\examples{
\dontrun{
library(raster)
library(rgdal)
#  Make list of maps from package database to load, and what functions to use to load them
fileList <-
   data.frame(files =
     dir(file.path(
                   find.package("SpaDES",
                                lib.loc=getOption("devtools.path"),
                                quiet=FALSE),
                  "maps"),
        full.names=TRUE, pattern= "tif"),
     functions="rasterToMemory",
     .stackName="landscape",
     packages="SpaDES",
     stringsAsFactors=FALSE)

# Load files to memory (using rasterToMemory) and stack them (because .stackName is provided above)
loadFiles(fileList=fileList)

# extract a single one of these rasters
DEM <- landscape$DEM

# can change color palette
setColors(landscape, n = 50)<-list(DEM=topo.colors(50),
                           forestCover = RColorBrewer::brewer.pal(9, "Set1"),
                           forestAge = RColorBrewer::brewer.pal("Blues", n=8),
                           habitatQuality = RColorBrewer::brewer.pal(9, "Spectral"),
                           percentPine = RColorBrewer::brewer.pal("GnBu", n=8))

#Make a new raster derived from a previous one; must give it a unique name
habitatQuality2 <- landscape$habitatQuality ^ 0.3
names(habitatQuality2) <- "habitatQuality2"

# make a SpatialPoints object
caribou <- SpatialPoints(coords=cbind(x=runif(1e2, -50, 50), y=runif(1e2, -50, 50)))


#Plot all maps on a new plot windows - Do not use RStudio window
\\notrun{
if(is.null(dev.list())) {
  dev(2)
} else {
  if(any(names(dev.list())=="RStudioGD")) {
    dev(which(names(dev.list())=="RStudioGD")+3)
  } else {
    dev(max(dev.list()))
  }
}
}

Plot(landscape)

# Can overplot, using addTo
Plot(caribou, addTo="landscape.forestAge", size=4, axes=FALSE)

# can add a plot to the plotting window
Plot(caribou, new=FALSE)

# Can add two maps with same name, if one is in a stack; they are given
#  unique names based on object name
Plot(landscape, caribou, DEM)

# can mix stacks, rasters, SpatialPoint*
Plot(landscape, habitatQuality2, caribou)

# can mix stacks, rasters, SpatialPoint*, and SpatialPolygons*
Plot(landscape, caribou)
Plot(habitatQuality2, new=FALSE)
Sr1 = Polygon(cbind(c(2, 4, 4, 1, 2), c(2, 3, 5, 4, 2))*20-50)
Sr2 = Polygon(cbind(c(5, 4, 2, 5), c(2, 3, 2, 2))*20-50)
Srs1 = Polygons(list(Sr1), "s1")
Srs2 = Polygons(list(Sr2), "s2")
SpP = SpatialPolygons(list(Srs1, Srs2), 1:2)
Plot(SpP)
Plot(SpP, addTo="landscape.forestCover", gp=gpar(lwd=2))

}
}

