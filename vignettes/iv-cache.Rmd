---
title: "04 Using Cache with `SpaDES`"
author:
  - "Eliot J. B. McIntire"
date: '`r strftime(Sys.Date(), "%B %d %Y")`'
output:
  rmarkdown::html_vignette:
    fig_width: 7
    number_sections: yes
    self_contained: yes
    toc: yes
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{03 Plotting with SpaDES}
  %\VignetteDepends{igraph, RColorBrewer, SpaDES}
  %\VignetteKeyword{visualization, plotting, mapping}
  %\VignetteEncoding{UTF-8}
---


As part of a reproducible work flow, caching of various function calls are a critical component.
Down the road, it is likely that an entire work flow from raw data to publication, decision support, report writing, presentation building etc., could be built and be reproducible anywhere, on demand.
The `reproducible::Cache` function is built to work with any R function. 
However, it becomes very powerful in a `SpaDES` context because we can build large, powerful applications that are transparent and tied to the raw data that may be *many* conceptual steps upstream in the workflow. 
To do this, we have built several customizations within the `SpaDES` package. 
Important to this is dealing correctly with the `simList`, which is an object that has slot
that is an environment. But more important are the various tools that can be used at
higher levels, i.e., not just for "standard" functions.

# Caching as part of SpaDES:

Some of the details of the `simList`-specific features of this `Cache` function include:

The function converts all elements that have an environment as part of their attributes
into a format that has no unique environment attribute, using `format` if a function, 
and `as.list` in the case of the `simList` environment.

When used within SpaDES modules, `Cache` (capital C) does not require that the argument `cacheRepo` be specified. If called
from inside a SpaDES module, `Cache` will use the cacheRepo from a call
to `cachePath(sim)`, taking the sim from the call stack. Similarly, if no
`cacheRepo` is specified, then it will use `getOption("spades.cachePath") `, which
will, by default, be a temporary location with no persistence between R sessions!
To persist between sessions, use `SpaDES::setPaths()` every session.

In a `SpaDES` context, there are several levels of caching that can be used
as part of a reproducible workflow. Each level can be used to a modeler's
advantage; and, all can be -- and are often -- used concurrently.

## `spades` or `experiment`:

And entire call to `spades` or `experiment` can be cached. This will have the effect
of eliminating any stochasticity in the model as the output will simply be
the cached version of the `simList`. This is likely most useful in
situations where reproducibility is more important than "new" stochasticity
(e.g., building decision support systems, apps, final version of a manuscript).

## Module-level caching:

If the parameter `.useCache` in the module's metadata
is set to TRUE, then the `doEvent.moduleName`
will be cached. That means that every time that module
is called from within a spades or experiment call, `Cache` will be called. Only
the objects inside the `simList` that correspond to the `inputObjects` of the
module and the `outputObjects` from the module (as specified in the module
metadata) will be assessed for caching
inputs or output, respectively.

In general use, module level caching would be mostly useful for modules that have
no stochasticity, such as data-preparation modules, GIS modules etc.

## Event-level caching:

If the parameter `.useCache` in the module's metadata
is set to a character or character vector,
then that or those event(s) will be cached. That means that every time the event
is called from within a spades or experiment call, `Cache` will be called.
Only
the objects inside the `simList` that correspond to the `inputObjects` or the
`outputObjects` as defined in the module metadata  will be assessed for caching
inputs or output, respectively. The fact that all and only the named `inputObjects`
and `outputObjects` are cached and returned may be inefficient (i.e., it may
cache more objects than are necessary) for individual events.

Similar to module-level caching, event-level caching would be mostly
useful for events that have
no stochasticity, such as data-preparation events, GIS events etc.

## Function-level caching:

Any function can be cached using:
`Cache(FUN = functionName, ...)`

This will be a slight change to a function call, such as:
`projectRaster(raster, crs = crs(newRaster))`
to
`Cache(projectRaster, raster, crs = crs(newRaster))`.

# The work flow

In general, we feel that a liberal use of `Cache` will make a re-useable and reproducible work flow. 
`shiny` apps can be made, taking advantage of `Cache`. 
Indeed, much of the difficulty in managing data sets and saving them for future use, can be accommodated by caching.
